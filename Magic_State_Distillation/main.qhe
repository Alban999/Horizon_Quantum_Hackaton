include logical_gates.qhe

# n_log is number of logical qubits, n_phys_per_log is number of physical qubits per logical qubit

5 -> n_log_msd
2 -> n_phys_per_log_msd
2 -> n_ancilla_per_log_msd
2.0 * 0.4776583 -> theta
2.0 * (-2.74889) -> phi


# Initialize qubits
increment i to n_log  # Loop over logical qubits
    increment j to n_phys_per_log  # Loop over physical qubits per logical qubit
        i+j -> index
        qubit -> qubit_array.[index]
    next
    increment k to n_ancilla_per_log
        i+k -> index
        qubit -> ancilla_array.[index]
    next
next

gosub msd

sub msd
    # Magic State Distillation subroutine (derived from arXiv:2310.12106)
    repeat
        gosub noisy_state_prep
        gosub adjoint_encode
        gosub measure_syndromes
        c == 0 -> c
    until c
endsub


sub noisy_state_prep
    # Noisy state prep subroutine (derived from arXiv:2310.12106, Fig 1)
    increment i to n_log
        increment j to n_phys_per_log
            i+j -> index
            ry(phi)[qubit_array.[index]]
            rz(theta)[qubit_array.[index]]
        next
    next
endsub

sub adjoint_encode
    # Custom circuit provided in reference paper arXiv:2310.12106 (Fig 1)
    2-> logical_index1
    gosub logical_x
    3 -> logical_index1
    gosub logical_x
    4 -> logical_index1
    gosub logical_z
    5 -> logical_index1
    gosub logical_y

    0 -> logical_index1
    increment i to 5
        i -> logical_index2
        gosub logical_cx
    next

    5 -> logical_index1
    gosub logical_h

    4 -> logical_index2
    gosub logical_swap
    increment i to 5
        i ~= 3 -> check
        if check
            i -> logical_index1
            gosub logical_h
        end
    next

    4 -> logical_index1
    5 -> logical_index2
    gosub logical_cx

    2 -> logical_index1
    gosub logical_cx

    4 -> logical_index1
    gosub logical_h
    1 -> logical_index1
    4 -> logical_index2
    gosub logical_cx
    2 -> logical_index1
    3 -> logical_index2
    gosub logical_cx

    1 -> logical_index1
    gosub logical_cx
    2 -> logical_index1
    gosub logical_h

    1 -> logical_index1
    2 -> logical_index2
    gosub logical_cx
    gosub logical_h

    5 -> logical_index1
    4 -> logical_index2
    gosub logical_cx

    3 -> logical_index2
    gosub logical_cx

    4 -> logical_index1
    gosub logical_cx

    3 -> logical_index1
    2 -> logical_index2
    gosub logical_cx
    5 -> logical_index1
    1 -> logical_index2
    gosub logical_cx
    4 -> logical_index1
    gosub logical_cx
    2 -> logical_index1
    gosub logical_cx

endsub