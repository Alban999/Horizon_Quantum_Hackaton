{\rtf1\ansi\ansicpg1252\cocoartf2758
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # This is your source file. You'll need a main.qhe file for us to compile your code. \
\
sub logical_x\
    increment i to n_log\
        if logical_index1 == i\
        qubit_array.[n_phys_per_log*logical_index1 + i-1] -> qubit_reg.[i]\
        x[qubit_reg.[i]]\
        end\
    next\
endsub\
\
sub logical_z\
    increment i to n_log\
        if logical_index1 == i\
        qubit_array.[n_phys_per_log*logical_index1 + i-1] -> qubit_reg.[i]\
        z[qubit_reg.[i]]\
        end\
    next\
endsub\
\
sub logical_h\
    increment i to n_log\
        if logical_index1 == i\
        qubit_array[n_phys_per_log*logical_index1 + i-1] -> qubit_reg.[i]\
        h[qubit_reg.[i]]\
        end\
    next\
endsub\
\
sub logical_y\
    increment i to n_log\
        if logical_index1 == i\
        qubit_array.[n_phys_per_log*logical_index1 + i-1] -> qubit_reg.[i]\
        y[qubit_reg.[i]]\
        end\
    next\
endsub\
\
sub logical_cx\
# TODO: Implement real logical CX\
increment i to 5\
    if logical_index1 == i\
    qubit_array.[n_phys_per_log*logical_index1 + i-1] = qubit_reg[i]\
    cnot[qubit_reg.[i]]\
    end\
next\
end sub\
sub noisy_state_prep\
    # Noisy state prep\
    increment i to n_log\
        increment j to n_phys_per_log\
            ry(phi)[qubit_array[i+j]]\
            rz(theta)[qubit_array[i+j]]\
        next\
    next\
endsub\
sub adjoint_encode\
    qubit_ref -> _input.[1]\
    2-> logical_index1\
    gosub logical_x\
    3 -> logical_index1\
    gosub logical_x\
    4 -> logical_index1\
    gosub logical_z\
    5 -> logical_index1\
    gosub logical_y\
    \
    0 -> logical_index1\
    increment i to 5\
        i -> logical_index2\
        gosub logical_cx\
    \
    5 -> logical_index1\
    gosub logical_h\
    \
    4 -> logical_index2\
    gosub logical_swap\
    increment i to 5\
        if i ~= 3\
        i -> logical_index1\
        gosub logical_h\
        end\
    next \
    \
    4 -> logical_index1\
    5 -> logical_index2\
    gosub logical_cx\
    \
    2 -> logical_index1\
    gosub logical_cx\
        \
    4 -> logical_index1\
    gosub logical_h\
    1 -> logical_index1\
    4 -> logical_index2\
    gosub logical_cx\
    2 -> logical_index1\
    3 -> logical_index2\
    gosub logical_cx\
    \
    1 -> logical_index1\
    gosub logical_cx\
    2 -> logical_index1\
    gosub logical_h\
    \
    1 -> logical_index1\
    2 -> logical_index2\
    gosub logical_cx\
    gosub logical_h\
    \
    5 -> logical_index1\
    4 -> logical_index2\
    gosub logical_cx\
    \
    3 -> logical_index2\
    gosub logical_cx\
    \
    4 -> logical_index1\
    gosub logical_cx\
    \
    3 -> logical_index1\
    2 -> logical_index2\
    gosub logical_cx\
    5 -> logical_index1\
    1 -> logical_index2\
    gosub logical_cx\
    4 -> logical_index1\
    gosub logical_cx\
    2 -> logical_index1\
    gosub logical_cx\
    \
endsub\
\
# n_log is number of logical qubits, n_phys_per_log is number of physical qubits per logical qubit\
3 -> n_log\
5 -> n_phys_per_log\
2.0 * 0.4776583 -> theta\
2.0 * (-2.74889) -> phi\
increment i to n_log\
    increment j to n_phys_per_log\
        qubit qubit_array.[i+j]\
    next\
next\
\
repeat\
    gosub noisy_state prep\
    gosub adjoint_encode\
    gosub measure_syndromes\
    #TODO: Retrieve measurement variables\
    0 -> c\
    increment i to n_log\
    c + measurement.[i] -> c\
    next\
until c == 0}