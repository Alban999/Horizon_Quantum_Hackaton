# This is your source file. You'll need a main.qhe file for us to compile your code.


sub noisy_state_prep
    # Noisy state prep
    increment i to n_log
        increment j to n_phys_per_log
            i+j -> index
            ry(phi)[qubit_array.[index]]
            rz(theta)[qubit_array.[index]]
        next
    next
endsub
sub adjoint_encode
    2-> logical_index1
    gosub logical_x
    3 -> logical_index1
    gosub logical_x
    4 -> logical_index1
    gosub logical_z
    5 -> logical_index1
    gosub logical_y

    0 -> logical_index1
    increment i to 5
        i -> logical_index2
        gosub logical_cx

    5 -> logical_index1
    gosub logical_h

    4 -> logical_index2
    gosub logical_swap
    increment i to 5
        i ~= 3 -> check
        if check
        i -> logical_index1
        gosub logical_h
        end
    next

    4 -> logical_index1
    5 -> logical_index2
    gosub logical_cx

    2 -> logical_index1
    gosub logical_cx

    4 -> logical_index1
    gosub logical_h
    1 -> logical_index1
    4 -> logical_index2
    gosub logical_cx
    2 -> logical_index1
    3 -> logical_index2
    gosub logical_cx

    1 -> logical_index1
    gosub logical_cx
    2 -> logical_index1
    gosub logical_h

    1 -> logical_index1
    2 -> logical_index2
    gosub logical_cx
    gosub logical_h

    5 -> logical_index1
    4 -> logical_index2
    gosub logical_cx

    3 -> logical_index2
    gosub logical_cx

    4 -> logical_index1
    gosub logical_cx

    3 -> logical_index1
    2 -> logical_index2
    gosub logical_cx
    5 -> logical_index1
    1 -> logical_index2
    gosub logical_cx
    4 -> logical_index1
    gosub logical_cx
    2 -> logical_index1
    gosub logical_cx

endsub

# n_log is number of logical qubits, n_phys_per_log is number of physical qubits per logical qubit
2 -> n_log
5 -> n_phys_per_log
2.0 * 0.4776583 -> theta
2.0 * (-2.74889) -> phi

# Initialize qubits
increment i to n_log
    increment j to n_phys_per_log
        i+j -> index
        qubit -> qubit_array.[index]
    next
next

repeat
    gosub noisy_state_prep
    gosub adjoint_encode
    #gosub measure_syndromes
    #TODO: Retrieve measurement variables
    0 -> c

    increment i to n_log
        0 -> measurement.[i]
        c + measurement.[i] -> c
    next
    c == 0 -> c
until c