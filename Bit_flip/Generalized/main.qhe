# This is your source file. Youâ€™ll need a main.qhe file for us to compile your code.
include constants.qh
#include maybe_flip.py
#include bitflip_noise.c2q
include protocols.qhe
# Define the initial psi state
increment i to num_qubits
    qubit -> in.[i]
next

protocol == 1 -> is_protocol_bitflip
protocol == 2 -> is_protocol_phaseflip
protocol == 3 -> is_protocol_five_qubit

if is_protocol_bitflip
    # Copy psi to the 2 ancillary registers
    increment i to num_qubits
        i-1 -> i0
        i+num_qubits-1 -> i1
        i+2*num_qubits-1 -> i2
        cnot[in.[i0], in.[i1]]
        cnot[in.[i0], in.[i2]]
    next
    # Apply the operations by embedding the flip corrector after each gate
    increment j to num_operations
        j -1 -> i
        ops.[i] -> op
        q_is.[i] -> q_i
        op == 1 -> is_s
        op == 2 -> is_h
        op == 3 -> is_t
        op == 4 -> is_cnot
        if is_cnot
            q_js.[i] -> q_j
        end
        gosub bitFLipless_gate
    next
end

if is_protocol_phaseflip
    # Copy psi to the 2 ancillary registers
    increment i to num_qubits
        i-1 -> i0
        i+num_qubits-1 -> i1
        i+2*num_qubits-1 -> i2
        cnot[in.[i0], in.[i1]]
        cnot[in.[i0], in.[i2]]
        h[in.[i0]]
        h[in.[i1]]
        h[in.[i2]]
    next
    # Apply the operations by embedding the flip corrector after each gate
    increment j to num_operations
        j -1 -> i
        ops.[i] -> op
        q_is.[i] -> q_i
        op == 1 -> is_s
        op == 2 -> is_h
        op == 3 -> is_t
        op == 4 -> is_cnot
        if is_cnot
            q_js.[i] -> q_j
        end
        gosub phaseFLipless_gate
    next
end

if is_protocol_five_qubit
    # Implementantion of 5-qubit EC code
    # Need 5n + 4 physical qubits for n logical ones
    # Convention: Last 4 are ancillas other 5n encode the logical qubits
    # Setting up the parameters
    # Initialising state
    increment i to num_qubits
        i-1 -> i0
        i+num_qubits-1 -> i1
        i+2*num_qubits-1 -> i2
        i+3*num_qubits-1 -> i3
        i+4*num_qubits-1 -> i4
        cnot[in.[i0], in.[i1]]
        cnot[in.[i0], in.[i2]]
        cnot[in.[i0], in.[i3]]
        cnot[in.[i0], in.[i4]]
    next
    # Apply the operations by embedding the 5-qubit corrector after each gate
    increment j to num_operations
        j-1 -> i
        ops.[i] -> op
        q_is.[i] -> q_i
        op == 1 -> is_s
        op == 2 -> is_h
        op == 3 -> is_t
        op == 4 -> is_cnot
        if is_cnot
            q_js.[i] -> q_j
        end
        #Applying the operations to physical qubits
        gosub apply_5Q_gates
        
        #Applying the noise
        if is_cnot
            q_i -> q_t
            gosub apply_5Q_rotation_noise
            q_j -> q_t 
            gosub apply_5Q_rotation_noise
        end
        
        if ~is_cnot
            q_i -> q_t
            gosub apply_5Q_rotation_noise
        end
        
        #Applying the error correcting code
        # In case we are applying CNOT, we correct both qubits
        if is_cnot
            #applying to q_i
            q_i -> q_t      #defining target
            gosub five_q_gate
            #applying to q_j
            q_j -> q_t      #defining target
            gosub five_q_gate
        end
        if ~is_cnot
            q_j -> q_t      #defining target
            gosub five_q_gate
        end
        
    next
end
